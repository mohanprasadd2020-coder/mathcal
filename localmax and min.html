<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Maximum & Minimum Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            padding: 40px 20px;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.95;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-top: 30px;
        }

        @media (max-width: 968px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 1.1em;
        }

        .input-group input {
            width: 100%;
            padding: 16px 18px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-size: 1.1em;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        .hint {
            font-size: 0.9em;
            color: #666;
            margin-top: 6px;
            font-style: italic;
        }

        .btn-calculate {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-calculate:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-calculate:active {
            transform: translateY(-1px);
        }

        .results-container {
            grid-column: 1 / -1;
            display: none;
        }

        .results-container.active {
            display: block;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .result-box {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 15px;
            border-left: 6px solid #667eea;
        }

        .result-box.maximum {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe0e0 100%);
            border-left-color: #dc3545;
        }

        .result-box.minimum {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            border-left-color: #28a745;
        }

        .result-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .result-title.max {
            color: #dc3545;
        }

        .result-title.min {
            color: #28a745;
        }

        .point-info {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 12px;
        }

        .point-label {
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .point-value {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            color: #333;
        }

        .no-points {
            text-align: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        #plot-container {
            background: white;
            padding: 25px;
            border-radius: 20px;
            margin-bottom: 25px;
        }

        #plot {
            width: 100%;
            height: 550px;
            border-radius: 12px;
        }

        .steps-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
        }

        .steps-container h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 1.8em;
        }

        .step {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 18px;
            border-left: 4px solid #764ba2;
            transition: all 0.3s;
        }

        .step:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .step-number {
            display: inline-block;
            background: #764ba2;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            text-align: center;
            line-height: 32px;
            font-weight: 700;
            margin-right: 12px;
        }

        .step-title {
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
            font-size: 1.15em;
        }

        .step-content {
            color: #555;
            line-height: 1.7;
            font-size: 1.05em;
        }

        .formula {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #e0e0e0;
            font-size: 1.05em;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #c33;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .stat-number {
            font-size: 2.5em;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 1em;
            margin-top: 5px;
        }

        .icon {
            font-size: 1.2em;
        }

        .critical-points-display {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 10px;
            margin-top: 10px;
            border-left: 4px solid #2196F3;
        }

        .critical-point {
            font-family: 'Courier New', monospace;
            color: #1565C0;
            font-weight: 600;
        }

        .concavity-container {
            background: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 25px;
        }

        .concavity-container h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 1.8em;
        }

        .concavity-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .concavity-box {
            padding: 25px;
            border-radius: 15px;
            border-left: 6px solid;
        }

        .concavity-box.up {
            background: linear-gradient(135deg, #f0fff4 0%, #c6f6d5 100%);
            border-left-color: #28a745;
        }

        .concavity-box.down {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe0e0 100%);
            border-left-color: #dc3545;
        }

        .concavity-box.inflection {
            background: linear-gradient(135deg, #fff9e6 0%, #ffe4a3 100%);
            border-left-color: #ffc107;
        }

        .concavity-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .concavity-title.up-color {
            color: #28a745;
        }

        .concavity-title.down-color {
            color: #dc3545;
        }

        .concavity-title.inflection-color {
            color: #ff8c00;
        }

        .interval-display {
            background: white;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 1.05em;
        }

        .concavity-visual {
            text-align: center;
            font-size: 3em;
            margin: 15px 0;
        }
    </style>
</head>
<body>
   
    <div class="container">
        <div class="header">
            <h1>üìä Local Maximum & Minimum Calculator</h1>
            <p>Automatically find extrema using derivatives - just enter your function!</p>
        </div>

        <div class="main-content">
            <div class="card">
                <h2><span class="icon">‚öôÔ∏è</span> Input Function</h2>
                
                <div class="input-group">
                    <label for="equation">Enter Function f(x):</label>
                    <input type="text" id="equation" placeholder="x^3 - 6*x^2 + 9*x + 1" value="x^3 - 6*x^2 + 9*x + 1">
                    <div class="hint">The calculator will automatically find all critical points using derivatives</div>
                </div>

                <button class="btn-calculate" onclick="calculateExtrema()">
                    Find Extrema
                </button>
            </div>

            <div class="card">
                <h2><span class="icon">üí°</span> How It Works</h2>
                <div style="line-height: 1.8; color: #555;">
                    <p style="margin-bottom: 15px;"><strong>Automatic Analysis:</strong></p>
                    <ol style="padding-left: 20px;">
                        <li style="margin-bottom: 10px;">Calculates f'(x) = 0 to find critical points</li>
                        <li style="margin-bottom: 10px;">Uses f''(x) to classify each point</li>
                        <li style="margin-bottom: 10px;">Determines local maxima and minima</li>
                        <li style="margin-bottom: 10px;">Shows complete step-by-step solution</li>
                    </ol>
                    
                    <p style="margin-top: 20px; margin-bottom: 10px;"><strong>Supported Functions:</strong></p>
                    <ul style="padding-left: 20px; list-style: none;">
                        <li>‚Ä¢ Polynomials: x^3 - 2*x^2 + x</li>
                        <li>‚Ä¢ Trigonometric: sin(x), cos(x)</li>
                        <li>‚Ä¢ Exponential: exp(-x^2)</li>
                        <li>‚Ä¢ Combinations: x^2 * sin(x)</li>
                        <li>‚Ä¢ Rational: (x^2 - 1)/(x + 1)</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="results-container" id="results">
            <div id="error-message"></div>

            <div class="card">
                <div class="summary-stats" id="summary-stats"></div>
            </div>

            <div id="plot-container">
                <div id="plot"></div>
            </div>

            <div class="card">
                <h2><span class="icon">üìç</span> Local Extrema Points</h2>
                <div class="results-grid" id="extrema-results"></div>
            </div>

            <div class="concavity-container">
                <h2><span class="icon">„Ä∞Ô∏è</span> Concavity Analysis</h2>
                <div id="concavity-content"></div>
            </div>

            <div class="steps-container">
                <h2><span class="icon">üìù</span> Step-by-Step Solution</h2>
                <div id="solution-steps"></div>
            </div>
        </div>
    </div>

    <script>
        function calculateExtrema() {
            const equation = document.getElementById('equation').value.trim();

            const resultsSection = document.getElementById('results');
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = '';

            if (!equation) {
                errorDiv.innerHTML = '<div class="error">‚ö†Ô∏è Please enter a function!</div>';
                resultsSection.classList.add('active');
                return;
            }

            try {
                // Parse function
                const expr = math.parse(equation);
                const f = expr.compile();

                // First derivative
                const derivative1 = math.derivative(expr, 'x');
                const f_prime = derivative1.compile();

                // Second derivative
                const derivative2 = math.derivative(derivative1, 'x');
                const f_double_prime = derivative2.compile();

                // Try to solve f'(x) = 0 symbolically
                let criticalPoints = [];
                try {
                    const solutions = math.rationalize(derivative1).simplify();
                    const solvedPoints = solveCriticalPointsSymbolically(derivative1);
                    
                    if (solvedPoints.length > 0) {
                        criticalPoints = solvedPoints.filter(x => !isNaN(x) && isFinite(x));
                    }
                } catch (e) {
                    console.log("Symbolic solving failed, using numerical method");
                }

                // If symbolic solving fails or returns no points, use numerical method
                if (criticalPoints.length === 0) {
                    // Determine search range based on function behavior
                    const searchRange = determineSearchRange(f, f_prime);
                    criticalPoints = findCriticalPointsNumerical(f_prime, searchRange.min, searchRange.max);
                }

                // Classify extrema
                const extrema = classifyExtrema(criticalPoints, f, f_double_prime);

                // Separate maxima and minima
                const maxima = extrema.filter(e => e.type === 'Local Maximum');
                const minima = extrema.filter(e => e.type === 'Local Minimum');

                // Determine plot range based on critical points
                let plotRange;
                if (criticalPoints.length > 0) {
                    const xMin = Math.min(...criticalPoints);
                    const xMax = Math.max(...criticalPoints);
                    const padding = Math.max(Math.abs(xMax - xMin) * 0.5, 2);
                    plotRange = {
                        min: xMin - padding,
                        max: xMax + padding
                    };
                } else {
                    plotRange = { min: -10, max: 10 };
                }

                // Analyze concavity
                const concavityAnalysis = analyzeConcavity(f_double_prime, criticalPoints, plotRange.min, plotRange.max);

                // Display results
                displaySummaryStats(maxima.length, minima.length, criticalPoints.length);
                displayExtremaResults(maxima, minima);
                displayConcavityAnalysis(concavityAnalysis, derivative2.toString());
                displaySolutionSteps(equation, derivative1.toString(), derivative2.toString(), maxima, minima, criticalPoints);
                plotGraph(f, maxima, minima, plotRange.min, plotRange.max, concavityAnalysis);

                resultsSection.classList.add('active');

            } catch (error) {
                errorDiv.innerHTML = `<div class="error"><strong>‚ö†Ô∏è Error:</strong> ${error.message}<br><br>Please check your function syntax.</div>`;
                resultsSection.classList.add('active');
            }
        }

        function solveCriticalPointsSymbolically(derivative1) {
            try {
                // Try to solve algebraically for simple cases
                const derivStr = derivative1.toString();
                
                // Handle simple polynomials
                if (derivStr.match(/^[0-9\s\+\-\*x\^]+$/)) {
                    // For quadratic derivatives: ax + b = 0
                    const match = derivStr.match(/(-?\d*\.?\d*)\s*\*?\s*x\s*\+?\s*(-?\d+\.?\d*)/);
                    if (match) {
                        const a = parseFloat(match[1] || '1');
                        const b = parseFloat(match[2] || '0');
                        if (a !== 0) {
                            return [-b / a];
                        }
                    }
                    
                    // For quadratic form: ax^2 + bx + c = 0
                    const quadMatch = derivStr.match(/(-?\d*\.?\d*)\s*\*?\s*x\s*\^\s*2\s*\+?\s*(-?\d*\.?\d*)\s*\*?\s*x\s*\+?\s*(-?\d+\.?\d*)/);
                    if (quadMatch) {
                        const a = parseFloat(quadMatch[1] || '1');
                        const b = parseFloat(quadMatch[2] || '0');
                        const c = parseFloat(quadMatch[3] || '0');
                        
                        const discriminant = b * b - 4 * a * c;
                        if (discriminant >= 0) {
                            const x1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                            const x2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                            return [x1, x2].filter(x => isFinite(x));
                        }
                    }
                }
            } catch (e) {
                console.log("Symbolic solving error:", e);
            }
            return [];
        }

        function determineSearchRange(f, f_prime) {
            // Test function at various points to determine reasonable range
            let min = -10, max = 10;
            
            // Expand range if function is well-defined beyond default range
            for (let testX of [-50, -20, 20, 50]) {
                try {
                    const y = f.evaluate({x: testX});
                    if (isFinite(y)) {
                        if (testX < 0) min = Math.min(min, testX);
                        else max = Math.max(max, testX);
                    }
                } catch (e) {
                    break;
                }
            }
            
            return { min, max };
        }

        function findCriticalPointsNumerical(f_prime, xmin, xmax) {
            const criticalPoints = [];
            const step = (xmax - xmin) / 2000;
            let prevValue, prevSign;

            try {
                prevValue = f_prime.evaluate({x: xmin});
                prevSign = Math.sign(prevValue);
            } catch (e) {
                prevSign = 0;
            }

            for (let x = xmin + step; x <= xmax; x += step) {
                try {
                    const value = f_prime.evaluate({x: x});
                    const currentSign = Math.sign(value);

                    // Check for sign change
                    if (prevSign !== 0 && currentSign !== 0 && prevSign !== currentSign) {
                        // Refine using bisection
                        const criticalX = bisection(f_prime, x - step, x, 25);
                        
                        // Avoid duplicates
                        if (!criticalPoints.some(cp => Math.abs(cp - criticalX) < 0.001)) {
                            criticalPoints.push(criticalX);
                        }
                    }

                    // Check if very close to zero
                    if (Math.abs(value) < 0.0001 && !criticalPoints.some(cp => Math.abs(cp - x) < 0.01)) {
                        criticalPoints.push(x);
                    }

                    prevValue = value;
                    prevSign = currentSign;
                } catch (e) {
                    continue;
                }
            }

            return criticalPoints;
        }

        function bisection(f_prime, a, b, iterations) {
            for (let i = 0; i < iterations; i++) {
                const mid = (a + b) / 2;
                try {
                    const fMid = f_prime.evaluate({x: mid});
                    const fA = f_prime.evaluate({x: a});

                    if (Math.abs(fMid) < 0.00001) return mid;

                    if (Math.sign(fMid) === Math.sign(fA)) {
                        a = mid;
                    } else {
                        b = mid;
                    }
                } catch (e) {
                    return (a + b) / 2;
                }
            }
            return (a + b) / 2;
        }

        function classifyExtrema(criticalPoints, f, f_double_prime) {
            const extrema = [];

            for (const x of criticalPoints) {
                try {
                    const y = f.evaluate({x: x});
                    const secondDeriv = f_double_prime.evaluate({x: x});

                    if (!isFinite(y) || !isFinite(secondDeriv)) continue;

                    let type;
                    if (secondDeriv > 0.001) {
                        type = 'Local Minimum';
                    } else if (secondDeriv < -0.001) {
                        type = 'Local Maximum';
                    } else {
                        type = 'Inflection Point';
                    }

                    extrema.push({
                        x: x,
                        y: y,
                        type: type,
                        secondDeriv: secondDeriv
                    });
                } catch (e) {
                    continue;
                }
            }

            return extrema;
        }

        function analyzeConcavity(f_double_prime, criticalPoints, xmin, xmax) {
            const analysis = {
                concaveUp: [],
                concaveDown: [],
                inflectionPoints: []
            };

            // Find inflection points (where f''(x) = 0 or changes sign)
            const step = (xmax - xmin) / 1000;
            let prevSecondDeriv, prevSign;

            try {
                prevSecondDeriv = f_double_prime.evaluate({x: xmin});
                prevSign = Math.sign(prevSecondDeriv);
            } catch (e) {
                prevSign = 0;
            }

            const signChanges = [];

            for (let x = xmin + step; x <= xmax; x += step) {
                try {
                    const secondDeriv = f_double_prime.evaluate({x: x});
                    const currentSign = Math.sign(secondDeriv);

                    // Check for sign change
                    if (prevSign !== 0 && currentSign !== 0 && prevSign !== currentSign) {
                        const inflectionX = bisection(f_double_prime, x - step, x, 20);
                        
                        // Avoid duplicates
                        if (!signChanges.some(pt => Math.abs(pt - inflectionX) < 0.01)) {
                            signChanges.push(inflectionX);
                            analysis.inflectionPoints.push(inflectionX);
                        }
                    }

                    prevSecondDeriv = secondDeriv;
                    prevSign = currentSign;
                } catch (e) {
                    continue;
                }
            }

            // Determine intervals of concavity
            const testPoints = [xmin, ...analysis.inflectionPoints, xmax].sort((a, b) => a - b);
            
            for (let i = 0; i < testPoints.length - 1; i++) {
                const testX = (testPoints[i] + testPoints[i + 1]) / 2;
                
                try {
                    const secondDeriv = f_double_prime.evaluate({x: testX});
                    
                    if (secondDeriv > 0.001) {
                        analysis.concaveUp.push({
                            start: testPoints[i],
                            end: testPoints[i + 1]
                        });
                    } else if (secondDeriv < -0.001) {
                        analysis.concaveDown.push({
                            start: testPoints[i],
                            end: testPoints[i + 1]
                        });
                    }
                } catch (e) {
                    continue;
                }
            }

            return analysis;
        }

        function displayConcavityAnalysis(analysis, derivative2Str) {
            const concavityDiv = document.getElementById('concavity-content');
            
            let html = `
                <div class="step" style="margin-bottom: 20px;">
                    <div class="step-content">
                        <strong>Concavity Rules:</strong><br>
                        ‚Ä¢ When <strong>f''(x) &gt; 0</strong>: Function is <strong style="color: #28a745;">Concave Up</strong> ‚à™ (like a smile)<br>
                        ‚Ä¢ When <strong>f''(x) &lt; 0</strong>: Function is <strong style="color: #dc3545;">Concave Down</strong> ‚à© (like a frown)<br>
                        ‚Ä¢ When <strong>f''(x) = 0</strong> and changes sign: <strong style="color: #ff8c00;">Inflection Point</strong><br><br>
                        <div class="formula">f''(x) = ${derivative2Str}</div>
                    </div>
                </div>

                <div class="concavity-grid">
                    <div class="concavity-box up">
                        <div class="concavity-title up-color">‚à™ Concave Up</div>
                        <div class="concavity-visual">üòä</div>
                        <div style="color: #555; margin-bottom: 10px;">f''(x) &gt; 0</div>
            `;

            if (analysis.concaveUp.length === 0) {
                html += '<div style="text-align: center; color: #666; font-style: italic;">No intervals found</div>';
            } else {
                analysis.concaveUp.forEach((interval, idx) => {
                    const start = interval.start === -Infinity ? '-‚àû' : interval.start.toFixed(3);
                    const end = interval.end === Infinity ? '‚àû' : interval.end.toFixed(3);
                    html += `<div class="interval-display">Interval ${idx + 1}: (${start}, ${end})</div>`;
                });
            }

            html += `
                    </div>

                    <div class="concavity-box down">
                        <div class="concavity-title down-color">‚à© Concave Down</div>
                        <div class="concavity-visual">‚òπÔ∏è</div>
                        <div style="color: #555; margin-bottom: 10px;">f''(x) &lt; 0</div>
            `;

            if (analysis.concaveDown.length === 0) {
                html += '<div style="text-align: center; color: #666; font-style: italic;">No intervals found</div>';
            } else {
                analysis.concaveDown.forEach((interval, idx) => {
                    const start = interval.start === -Infinity ? '-‚àû' : interval.start.toFixed(3);
                    const end = interval.end === Infinity ? '‚àû' : interval.end.toFixed(3);
                    html += `<div class="interval-display">Interval ${idx + 1}: (${start}, ${end})</div>`;
                });
            }

            html += `
                    </div>

                    <div class="concavity-box inflection">
                        <div class="concavity-title inflection-color">‚ö° Inflection Points</div>
                        <div class="concavity-visual">üîÑ</div>
                        <div style="color: #555; margin-bottom: 10px;">f''(x) = 0 (sign change)</div>
            `;

            if (analysis.inflectionPoints.length === 0) {
                html += '<div style="text-align: center; color: #666; font-style: italic;">No inflection points found</div>';
            } else {
                analysis.inflectionPoints.forEach((x, idx) => {
                    html += `<div class="interval-display">Point ${idx + 1}: x = ${x.toFixed(6)}</div>`;
                });
            }

            html += `
                    </div>
                </div>
            `;

            concavityDiv.innerHTML = html;
        }

        function displaySummaryStats(maxCount, minCount, criticalCount) {
            const statsDiv = document.getElementById('summary-stats');
            statsDiv.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${maxCount}</div>
                    <div class="stat-label">Local Maxima</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${minCount}</div>
                    <div class="stat-label">Local Minima</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${criticalCount}</div>
                    <div class="stat-label">Critical Points Found</div>
                </div>
            `;
        }

        function displayExtremaResults(maxima, minima) {
            const resultsDiv = document.getElementById('extrema-results');
            let html = '';

            // Display maxima
            html += '<div class="result-box maximum">';
            html += '<div class="result-title max">üî∫ Local Maxima</div>';
            
            if (maxima.length === 0) {
                html += '<div class="no-points">No local maxima found</div>';
            } else {
                maxima.forEach((point, idx) => {
                    html += `
                        <div class="point-info">
                            <div class="point-label">Maximum ${idx + 1}:</div>
                            <div class="point-value">x = ${point.x.toFixed(6)}</div>
                            <div class="point-value">f(x) = ${point.y.toFixed(6)}</div>
                            <div class="point-value" style="font-size: 0.9em; color: #666;">f''(x) = ${point.secondDeriv.toFixed(6)} &lt; 0</div>
                        </div>
                    `;
                });
            }
            html += '</div>';

            // Display minima
            html += '<div class="result-box minimum">';
            html += '<div class="result-title min">üîª Local Minima</div>';
            
            if (minima.length === 0) {
                html += '<div class="no-points">No local minima found</div>';
            } else {
                minima.forEach((point, idx) => {
                    html += `
                        <div class="point-info">
                            <div class="point-label">Minimum ${idx + 1}:</div>
                            <div class="point-value">x = ${point.x.toFixed(6)}</div>
                            <div class="point-value">f(x) = ${point.y.toFixed(6)}</div>
                            <div class="point-value" style="font-size: 0.9em; color: #666;">f''(x) = ${point.secondDeriv.toFixed(6)} &gt; 0</div>
                        </div>
                    `;
                });
            }
            html += '</div>';

            resultsDiv.innerHTML = html;
        }

        function displaySolutionSteps(original, derivative1, derivative2, maxima, minima, criticalPoints) {
            const stepsDiv = document.getElementById('solution-steps');
            
            let html = `
                <div class="step">
                    <div class="step-title">
                        <span class="step-number">1</span>
                        Given Function
                    </div>
                    <div class="step-content">
                        <div class="formula">f(x) = ${original}</div>
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">2</span>
                        Calculate First Derivative f'(x)
                    </div>
                    <div class="step-content">
                        <div class="formula">f'(x) = ${derivative1}</div>
                        To find critical points, we solve f'(x) = 0
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">3</span>
                        Solve f'(x) = 0 for Critical Points
                    </div>
                    <div class="step-content">
                        Setting the derivative equal to zero and solving:<br>
                        <div class="formula">${derivative1} = 0</div>
                        ${criticalPoints.length > 0 ? 
                            '<div class="critical-points-display">Critical points found at:<br>' + 
                            criticalPoints.map((x, i) => `<span class="critical-point">x${i+1} = ${x.toFixed(6)}</span>`).join(', ') + 
                            '</div>' : 
                            '<div style="color: #c33; margin-top: 10px;">No critical points found</div>'}
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">4</span>
                        Calculate Second Derivative f''(x)
                    </div>
                    <div class="step-content">
                        <div class="formula">f''(x) = ${derivative2}</div>
                        Used to classify each critical point using the Second Derivative Test
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">5</span>
                        Apply Second Derivative Test
                    </div>
                    <div class="step-content">
                        For each critical point x = c:<br><br>
                        ‚Ä¢ If <strong>f''(c) &gt; 0</strong> ‚Üí The function is concave up at c ‚Üí <strong style="color: #28a745;">Local Minimum</strong><br>
                        ‚Ä¢ If <strong>f''(c) &lt; 0</strong> ‚Üí The function is concave down at c ‚Üí <strong style="color: #dc3545;">Local Maximum</strong><br>
                        ‚Ä¢ If <strong>f''(c) = 0</strong> ‚Üí Test is inconclusive, may be inflection point
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">6</span>
                        Classification Results
                    </div>
                    <div class="step-content">
            `;

            if (maxima.length > 0) {
                html += '<p style="margin-bottom: 10px;"><strong style="color: #dc3545;">Local Maxima:</strong></p>';
                maxima.forEach((max, idx) => {
                    html += `<div class="formula">At x = ${max.x.toFixed(4)}: f(${max.x.toFixed(4)}) = ${max.y.toFixed(4)}, f''(${max.x.toFixed(4)}) = ${max.secondDeriv.toFixed(4)} &lt; 0 ‚úì</div>`;
                });
            }

            if (minima.length > 0) {
                html += '<p style="margin: 15px 0 10px 0;"><strong style="color: #28a745;">Local Minima:</strong></p>';
                minima.forEach((min, idx) => {
                    html += `<div class="formula">At x = ${min.x.toFixed(4)}: f(${min.x.toFixed(4)}) = ${min.y.toFixed(4)}, f''(${min.x.toFixed(4)}) = ${min.secondDeriv.toFixed(4)} &gt; 0 ‚úì</div>`;
                });
            }

            if (maxima.length === 0 && minima.length === 0) {
                html += '<p style="color: #c33;">No local extrema found. The function may be monotonic or have no critical points in the domain.</p>';
            }

            html += `
                    </div>
                </div>

                <div class="step">
                    <div class="step-title">
                        <span class="step-number">7</span>
                        Concavity Interpretation
                    </div>
                    <div class="step-content">
                        The second derivative f''(x) also tells us about the concavity of the function:<br><br>
                        ‚Ä¢ <strong style="color: #28a745;">Concave Up (‚à™)</strong>: The function curves upward like a cup. The tangent line lies below the curve.<br>
                        ‚Ä¢ <strong style="color: #dc3545;">Concave Down (‚à©)</strong>: The function curves downward. The tangent line lies above the curve.<br>
                        ‚Ä¢ <strong style="color: #ff8c00;">Inflection Points</strong>: Points where concavity changes from up to down or vice versa.<br><br>
                        See the Concavity Analysis section above for detailed intervals.
                    </div>
                </div>
            `;

            stepsDiv.innerHTML = html;
        }

        function plotGraph(f, maxima, minima, xmin, xmax, concavityAnalysis) {
            const numPoints = 1000;
            const step = (xmax - xmin) / numPoints;
            const xValues = [];
            const yValues = [];

            for (let x = xmin; x <= xmax; x += step) {
                try {
                    const y = f.evaluate({x: x});
                    if (isFinite(y)) {
                        xValues.push(x);
                        yValues.push(y);
                    }
                } catch (e) {
                    continue;
                }
            }

            const traces = [{
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines',
                name: 'f(x)',
                line: {
                    color: '#667eea',
                    width: 3
                }
            }];

            // Add maxima points
            if (maxima.length > 0) {
                traces.push({
                    x: maxima.map(p => p.x),
                    y: maxima.map(p => p.y),
                    type: 'scatter',
                    mode: 'markers+text',
                    name: 'Local Max',
                    text: maxima.map((p, i) => `Max ${i + 1}`),
                    textposition: 'top center',
                    marker: {
                        color: '#dc3545',
                        size: 15,
                        symbol: 'triangle-down',
                        line: {
                            color: 'white',
                            width: 2
                        }
                    }
                });
            }

            // Add minima points
            if (minima.length > 0) {
                traces.push({
                    x: minima.map(p => p.x),
                    y: minima.map(p => p.y),
                    type: 'scatter',
                    mode: 'markers+text',
                    name: 'Local Min',
                    text: minima.map((p, i) => `Min ${i + 1}`),
                    textposition: 'bottom center',
                    marker: {
                        color: '#28a745',
                        size: 15,
                        symbol: 'triangle-up',
                        line: {
                            color: 'white',
                            width: 2
                        }
                    }
                });
            }

            // Add inflection points
            if (concavityAnalysis.inflectionPoints.length > 0) {
                const inflectionYValues = concavityAnalysis.inflectionPoints.map(x => {
                    try {
                        return f.evaluate({x: x});
                    } catch (e) {
                        return null;
                    }
                }).filter(y => y !== null && isFinite(y));

                if (inflectionYValues.length > 0) {
                    traces.push({
                        x: concavityAnalysis.inflectionPoints.slice(0, inflectionYValues.length),
                        y: inflectionYValues,
                        type: 'scatter',
                        mode: 'markers+text',
                        name: 'Inflection Points',
                        text: concavityAnalysis.inflectionPoints.map((p, i) => `IP ${i + 1}`),
                        textposition: 'middle right',
                        marker: {
                            color: '#ffc107',
                            size: 12,
                            symbol: 'diamond',
                            line: {
                                color: 'white',
                                width: 2
                            }
                        }
                    });
                }
            }

            // Add shaded regions for concavity
            const shapes = [];
            
            // Shade concave up regions (green)
            concavityAnalysis.concaveUp.forEach(interval => {
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: interval.start,
                    x1: interval.end,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(40, 167, 69, 0.1)',
                    line: { width: 0 },
                    layer: 'below'
                });
            });

            // Shade concave down regions (red)
            concavityAnalysis.concaveDown.forEach(interval => {
                shapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: interval.start,
                    x1: interval.end,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(220, 53, 69, 0.1)',
                    line: { width: 0 },
                    layer: 'below'
                });
            });

            const layout = {
                title: {
                    text: 'Function Graph with Extrema and Concavity',
                    font: {
                        size: 20,
                        family: 'Segoe UI'
                    }
                },
                xaxis: {
                    title: 'x',
                    gridcolor: '#e0e0e0',
                    zeroline: true,
                    zerolinecolor: '#333',
                    zerolinewidth: 2
                },
                yaxis: {
                    title: 'f(x)',
                    gridcolor: '#e0e0e0',
                    zeroline: true,
                    zerolinecolor: '#333',
                    zerolinewidth: 2
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white',
                hovermode: 'closest',
                showlegend: true,
                legend: {
                    x: 1,
                    y: 1,
                    xanchor: 'right',
                    bgcolor: 'rgba(255, 255, 255, 0.9)',
                    bordercolor: '#ccc',
                    borderwidth: 1
                },
                shapes: shapes,
                annotations: [
                    {
                        text: 'Green shading = Concave Up ‚à™',
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.02,
                        y: 0.98,
                        showarrow: false,
                        font: { size: 11, color: '#28a745' },
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        borderpad: 4
                    },
                    {
                        text: 'Red shading = Concave Down ‚à©',
                        xref: 'paper',
                        yref: 'paper',
                        x: 0.02,
                        y: 0.93,
                        showarrow: false,
                        font: { size: 11, color: '#dc3545' },
                        bgcolor: 'rgba(255, 255, 255, 0.8)',
                        borderpad: 4
                    }
                ]
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            Plotly.newPlot('plot', traces, layout, config);
        }

        // Auto-calculate on page load
        window.onload = function() {
            calculateExtrema();
        };
    </script>

        <!-- <button style="
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #2ea5f4;
    color: #fffbfb;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 50px;
    cursor: pointer;
"><a href="/index.html">bach to home</a></button></div>
</body> -->
</html>
 <i><a href="/eigenvalue and vector.html">Eigen value and Vector</a>
        <a href="/Eulers thorem.html">Eulers theorem</a>
        <a href="/double integrel.html">Double Integrals</a>
        <a href="/stokes theorem.html">Stokes Theorem</a></i>