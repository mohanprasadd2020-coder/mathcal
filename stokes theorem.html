<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stokes' Theorem Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #3c234c 0%, #9551d8 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #3c234c 0%, #9551d8 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .theorem-statement {
            background: #f8f9fa;
            padding: 25px;
            margin: 20px;
            border-radius: 10px;
            border-left: 5px solid #771fa0;
        }

        .theorem-statement h2 {
            color: #5c137e;
            margin-bottom: 15px;
        }

        .formula {
            font-size: 1.3em;
            text-align: center;
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        .input-section, .result-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
        }

        .input-section h3, .result-section h3 {
            color: #630e8d;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #a63aea;
        }

        .vector-inputs {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .vector-inputs input {
            text-align: center;
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3c234c 0%, #9551d8 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .result-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #902de7;
        }

        .result-box h4 {
            color: #1e3c72;
            margin-bottom: 10px;
        }

        .result-value {
            font-size: 1.2em;
            color: #333;
            font-family: 'Courier New', monospace;
        }

        #plot3d {
            width: 100%;
            height: 500px;
            background: white;
            border-radius: 10px;
            margin-top: 20px;
        }

        .visualization {
            grid-column: 1 / -1;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
        }

        .info-text {
            color: #666;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .steps {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .step {
            padding: 10px;
            margin: 8px 0;
            background: #f8f9fa;
            border-radius: 5px;
        }

        @media (max-width: 968px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
   
    <div class="container">
        <div class="header">
            <h1>üîÑ Stoke's Theorem Calculator</h1>
            <p>Interactive Vector Calculus Tool with 3D Visualization</p>
        </div>

        <div class="theorem-statement">
            <h2>Statement of Stoke's Theorem</h2>
            <p>If S is an open surface bounded by a simple closed curve C, and <strong>F‚Éó</strong> is continuous having continuous partial derivatives in S and C, then:</p>
            <div class="formula">
                ‚àÆ<sub>c</sub> F‚Éó ¬∑ dr‚Éó = ‚à¨<sub>S</sub> curl F‚Éó ¬∑ nÃÇ dS
            </div>
            <div class="formula">
                (or)
            </div>
            <div class="formula">
                ‚àÆ<sub>c</sub> F‚Éó ¬∑ dr‚Éó = ‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS
            </div>
            <p style="margin-top: 15px;"><strong>nÃÇ</strong> is the outward unit normal vector and C is traversed in the anti-clockwise direction.</p>
        </div>

        <div class="content">
            <div class="input-section">
                <h3>üìù Input Parameters</h3>
                
                <div class="input-group">
                    <label>Vector Field F‚Éó(x, y, z) = (P, Q, R)</label>
                    <div class="vector-inputs">
                        <input type="text" id="Px" placeholder="P(x,y,z)" value="y">
                        <input type="text" id="Qy" placeholder="Q(x,y,z)" value="x">
                        <input type="text" id="Rz" placeholder="R(x,y,z)" value="0">
                    </div>
                    <p class="info-text">Enter components as functions of x, y, z</p>
                </div>

                <div class="input-group">
                    <label>Surface Type</label>
                    <select id="surfaceType">
                        <option value="plane">Plane</option>
                        <option value="paraboloid">Paraboloid</option>
                        <option value="hemisphere">Hemisphere</option>
                        <option value="sphere">Sphere (upper half)</option>
                        <option value="cone">Cone</option>
                        <option value="cube">Cube (top face)</option>
                        <option value="parallelogram">Parallelogram</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Curve C (Boundary)</label>
                    <select id="curveType">
                        <option value="circle">Circle</option>
                        <option value="ellipse">Ellipse</option>
                        <option value="square">Square</option>
                        <option value="rectangle">Rectangle</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Radius / Size Parameter</label>
                    <input type="number" id="radius" value="1" step="0.1" min="0.1">
                </div>

                <div class="input-group">
                    <label>Height Parameter (for 3D surfaces)</label>
                    <input type="number" id="height" value="1" step="0.1">
                </div>

                <button class="btn" onclick="calculate()">üîç Calculate Stoke's Theorem</button>
                <button class="btn" onclick="visualize()" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);">üìä Visualize 3D</button>
            </div>

            <div class="result-section">
                <h3>üìä Results</h3>
                
                <div class="result-box">
                    <h4>Curl of F‚Éó (‚àá √ó F‚Éó)</h4>
                    <div class="result-value" id="curlResult">-</div>
                </div>

                <div class="result-box">
                    <h4>Line Integral: ‚àÆ<sub>c</sub> F‚Éó ¬∑ dr‚Éó</h4>
                    <div class="result-value" id="lineIntegral">-</div>
                </div>

                <div class="result-box">
                    <h4>Surface Integral: ‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS</h4>
                    <div class="result-value" id="surfaceIntegral">-</div>
                </div>

                <div class="result-box">
                    <h4>Verification</h4>
                    <div class="result-value" id="verification">-</div>
                </div>

                <div class="steps">
                    <h4>üìù Line Integral Calculation Steps</h4>
                    <div id="lineSteps"></div>
                </div>

                <div class="steps" style="margin-top: 15px;">
                    <h4>üìù Surface Integral Calculation Steps</h4>
                    <div id="surfaceSteps"></div>
                </div>

                <div class="steps" style="margin-top: 15px;">
                    <h4>‚úÖ Final Verification</h4>
                    <div id="steps"></div>
                </div>
            </div>

            <div class="visualization">
                <h3>üé® 3D Visualization</h3>
                <div id="plot3d"></div>
            </div>
        </div>
    </div>

    <script>
        function calculate() {
            try {
                const Px = document.getElementById('Px').value;
                const Qy = document.getElementById('Qy').value;
                const Rz = document.getElementById('Rz').value;
                const radius = parseFloat(document.getElementById('radius').value);
                const curveType = document.getElementById('curveType').value;
                const surfaceType = document.getElementById('surfaceType').value;

                // Calculate curl symbolically
                const curlX = `d(${Rz})/dy - d(${Qy})/dz`;
                const curlY = `d(${Px})/dz - d(${Rz})/dx`;
                const curlZ = `d(${Qy})/dx - d(${Px})/dy`;

                // For simple cases, calculate numerically
                let curlZValue, curlXValue, curlYValue;
                try {
                    const dQdx = math.derivative(Qy, 'x').toString();
                    const dPdy = math.derivative(Px, 'y').toString();
                    curlZValue = `${dQdx} - (${dPdy})`;
                    
                    const dRdy = math.derivative(Rz, 'y').toString();
                    const dQdz = math.derivative(Qy, 'z').toString();
                    curlXValue = `${dRdy} - (${dQdz})`;
                    
                    const dPdz = math.derivative(Px, 'z').toString();
                    const dRdx = math.derivative(Rz, 'x').toString();
                    curlYValue = `${dPdz} - (${dRdx})`;
                } catch (e) {
                    curlZValue = "1";
                    curlXValue = "0";
                    curlYValue = "0";
                }

                document.getElementById('curlResult').innerHTML = 
                    `‚àá √ó F‚Éó = (&lt;${curlXValue}&gt;, &lt;${curlYValue}&gt;, &lt;${curlZValue}&gt;)`;

                // Calculate line integral with detailed steps
                const lineResult = evaluateLineIntegral(Px, Qy, Rz, radius, curveType);
                document.getElementById('lineIntegral').innerHTML = lineResult.value.toFixed(6);

                // Calculate surface integral with detailed steps
                const surfResult = evaluateSurfaceIntegral(curlXValue, curlYValue, curlZValue, radius, surfaceType);
                document.getElementById('surfaceIntegral').innerHTML = surfResult.value.toFixed(6);

                // Verification
                const diff = Math.abs(lineResult.value - surfResult.value);
                const verified = diff < 0.01;
                document.getElementById('verification').innerHTML = 
                    verified ? 
                    `‚úÖ VERIFIED! Difference: ${diff.toFixed(8)}` : 
                    `‚ö†Ô∏è Check calculation. Difference: ${diff.toFixed(6)}`;

                // Display detailed steps
                displayLineSteps(lineResult.steps);
                displaySurfaceSteps(surfResult.steps);
                displayFinalVerification(Px, Qy, Rz, curlXValue, curlYValue, curlZValue, lineResult.value, surfResult.value);

            } catch (error) {
                alert('Error in calculation: ' + error.message);
            }
        }

        function evaluateLineIntegral(Px, Qy, Rz, r, curveType) {
            let sum = 0;
            const n = 200;
            let steps = [];
            
            steps.push(`<strong>Line Integral: ‚àÆ<sub>C</sub> F‚Éó ¬∑ dr‚Éó</strong>`);
            steps.push(`Given vector field: F‚Éó = (${Px}, ${Qy}, ${Rz})`);
            
            if (curveType === 'circle') {
                steps.push(`<strong>Parameterization of Circle (radius = ${r}):</strong>`);
                steps.push(`x(t) = ${r}cos(t), y(t) = ${r}sin(t), z(t) = 0`);
                steps.push(`where t ‚àà [0, 2œÄ]`);
                steps.push(`<strong>Derivatives:</strong>`);
                steps.push(`dx/dt = -${r}sin(t), dy/dt = ${r}cos(t), dz/dt = 0`);
                
                for (let i = 0; i < n; i++) {
                    const t = 2 * Math.PI * i / n;
                    const dt = 2 * Math.PI / n;
                    
                    const x = r * Math.cos(t);
                    const y = r * Math.sin(t);
                    const z = 0;
                    
                    const dx = -r * Math.sin(t) * dt;
                    const dy = r * Math.cos(t) * dt;
                    const dz = 0;
                    
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    
                    sum += P * dx + Q * dy + R * dz;
                }
                
                steps.push(`<strong>Integral Setup:</strong>`);
                steps.push(`‚àÆ<sub>C</sub> F‚Éó ¬∑ dr‚Éó = ‚à´<sub>0</sub><sup>2œÄ</sup> [P(dx/dt) + Q(dy/dt) + R(dz/dt)] dt`);
                steps.push(`= ‚à´<sub>0</sub><sup>2œÄ</sup> [P¬∑(-${r}sin(t)) + Q¬∑(${r}cos(t)) + R¬∑(0)] dt`);
                
            } else if (curveType === 'square') {
                steps.push(`<strong>Parameterization of Square (side length = ${2*r}):</strong>`);
                steps.push(`The square has four segments from (-${r}, -${r}) to (${r}, ${r})`);
                
                // Bottom edge: (-r, -r) to (r, -r)
                for (let i = 0; i < n/4; i++) {
                    const t = i / (n/4);
                    const x = -r + 2*r*t;
                    const y = -r;
                    const z = 0;
                    const dx = 2*r / (n/4);
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    sum += P * dx;
                }
                
                // Right edge: (r, -r) to (r, r)
                for (let i = 0; i < n/4; i++) {
                    const t = i / (n/4);
                    const x = r;
                    const y = -r + 2*r*t;
                    const z = 0;
                    const dy = 2*r / (n/4);
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    sum += Q * dy;
                }
                
                // Top edge: (r, r) to (-r, r)
                for (let i = 0; i < n/4; i++) {
                    const t = i / (n/4);
                    const x = r - 2*r*t;
                    const y = r;
                    const z = 0;
                    const dx = -2*r / (n/4);
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    sum += P * dx;
                }
                
                // Left edge: (-r, r) to (-r, -r)
                for (let i = 0; i < n/4; i++) {
                    const t = i / (n/4);
                    const x = -r;
                    const y = r - 2*r*t;
                    const z = 0;
                    const dy = -2*r / (n/4);
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    sum += Q * dy;
                }
                
                steps.push(`<strong>Four segments integrated separately</strong>`);
                steps.push(`Segment 1: Bottom edge, x varies, y = -${r}`);
                steps.push(`Segment 2: Right edge, x = ${r}, y varies`);
                steps.push(`Segment 3: Top edge, x varies, y = ${r}`);
                steps.push(`Segment 4: Left edge, x = -${r}, y varies`);
                
            } else if (curveType === 'ellipse') {
                const a = r;
                const b = r * 0.7;
                steps.push(`<strong>Parameterization of Ellipse (a = ${a.toFixed(2)}, b = ${b.toFixed(2)}):</strong>`);
                steps.push(`x(t) = ${a.toFixed(2)}cos(t), y(t) = ${b.toFixed(2)}sin(t), z(t) = 0`);
                
                for (let i = 0; i < n; i++) {
                    const t = 2 * Math.PI * i / n;
                    const dt = 2 * Math.PI / n;
                    const x = a * Math.cos(t);
                    const y = b * Math.sin(t);
                    const z = 0;
                    const dx = -a * Math.sin(t) * dt;
                    const dy = b * Math.cos(t) * dt;
                    const dz = 0;
                    const P = evalFunction(Px, x, y, z);
                    const Q = evalFunction(Qy, x, y, z);
                    const R = evalFunction(Rz, x, y, z);
                    sum += P * dx + Q * dy + R * dz;
                }
            } else if (curveType === 'rectangle') {
                const a = r;
                const b = r * 0.6;
                steps.push(`<strong>Parameterization of Rectangle (width = ${2*a}, height = ${2*b}):</strong>`);
                
                // Four edges of rectangle
                for (let i = 0; i < n/4; i++) {
                    const t = i / (n/4);
                    // Bottom
                    let x = -a + 2*a*t, y = -b, z = 0;
                    let dx = 2*a / (n/4), dy = 0, dz = 0;
                    sum += evalFunction(Px, x, y, z) * dx;
                    
                    // Right
                    x = a; y = -b + 2*b*t; z = 0;
                    dx = 0; dy = 2*b / (n/4); dz = 0;
                    sum += evalFunction(Qy, x, y, z) * dy;
                    
                    // Top
                    x = a - 2*a*t; y = b; z = 0;
                    dx = -2*a / (n/4); dy = 0; dz = 0;
                    sum += evalFunction(Px, x, y, z) * dx;
                    
                    // Left
                    x = -a; y = b - 2*b*t; z = 0;
                    dx = 0; dy = -2*b / (n/4); dz = 0;
                    sum += evalFunction(Qy, x, y, z) * dy;
                }
            }
            
            steps.push(`<strong>Numerical Integration Result:</strong>`);
            steps.push(`‚àÆ<sub>C</sub> F‚Éó ¬∑ dr‚Éó ‚âà ${sum.toFixed(6)}`);
            
            return { value: sum, steps: steps };
        }

        function evaluateSurfaceIntegral(curlX, curlY, curlZ, r, surfaceType) {
            let sum = 0;
            let steps = [];
            
            steps.push(`<strong>Surface Integral: ‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS</strong>`);
            steps.push(`Curl: ‚àá √ó F‚Éó = (&lt;${curlX}&gt;, &lt;${curlY}&gt;, &lt;${curlZ}&gt;)`);
            
            if (surfaceType === 'plane') {
                steps.push(`<strong>Surface: Plane z = 0</strong>`);
                steps.push(`Normal vector: nÃÇ = (0, 0, 1)`);
                steps.push(`(‚àá √ó F‚Éó) ¬∑ nÃÇ = ${curlZ}`);
                steps.push(`<strong>Integral in polar coordinates:</strong>`);
                steps.push(`‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS = ‚à´‚à´ (${curlZ}) r dr dŒ∏`);
                steps.push(`Integration bounds: r ‚àà [0, ${r}], Œ∏ ‚àà [0, 2œÄ]`);
                
                const n = 50;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const rho = r * i / n;
                        const theta = 2 * Math.PI * j / n;
                        const x = rho * Math.cos(theta);
                        const y = rho * Math.sin(theta);
                        const z = 0;
                        const curlVal = evalFunction(curlZ, x, y, z);
                        const dA = rho * (r / n) * (2 * Math.PI / n);
                        sum += curlVal * dA;
                    }
                }
                
            } else if (surfaceType === 'paraboloid') {
                steps.push(`<strong>Surface: Paraboloid z = x¬≤ + y¬≤</strong>`);
                steps.push(`Parameterization: r‚Éó(u,v) = (u, v, u¬≤ + v¬≤)`);
                steps.push(`Computing normal vector using cross product of partial derivatives`);
                
                const n = 40;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const u = (2 * r * i / n) - r;
                        const v = (2 * r * j / n) - r;
                        if (u*u + v*v <= r*r) {
                            const x = u, y = v, z = u*u + v*v;
                            const ru = [1, 0, 2*u];
                            const rv = [0, 1, 2*v];
                            const normal = [
                                -2*u,
                                -2*v,
                                1
                            ];
                            const curlVec = [
                                evalFunction(curlX, x, y, z),
                                evalFunction(curlY, x, y, z),
                                evalFunction(curlZ, x, y, z)
                            ];
                            const dotProd = curlVec[0]*normal[0] + curlVec[1]*normal[1] + curlVec[2]*normal[2];
                            const dA = (2*r/n) * (2*r/n);
                            sum += dotProd * dA;
                        }
                    }
                }
                steps.push(`Normal: n‚Éó = (-2x, -2y, 1)`);
                
            } else if (surfaceType === 'hemisphere' || surfaceType === 'sphere') {
                steps.push(`<strong>Surface: Hemisphere z = ‚àö(r¬≤ - x¬≤ - y¬≤)</strong>`);
                steps.push(`Radius: ${r}`);
                steps.push(`Normal vector points outward`);
                
                const n = 40;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const u = (2 * r * i / n) - r;
                        const v = (2 * r * j / n) - r;
                        if (u*u + v*v <= r*r) {
                            const x = u, y = v;
                            const zSq = r*r - u*u - v*v;
                            if (zSq >= 0) {
                                const z = Math.sqrt(zSq);
                                const normal = [x/r, y/r, z/r];
                                const curlVec = [
                                    evalFunction(curlX, x, y, z),
                                    evalFunction(curlY, x, y, z),
                                    evalFunction(curlZ, x, y, z)
                                ];
                                const dotProd = curlVec[0]*normal[0] + curlVec[1]*normal[1] + curlVec[2]*normal[2];
                                const dA = (2*r/n) * (2*r/n) * r / z;
                                sum += dotProd * dA;
                            }
                        }
                    }
                }
                steps.push(`Normal: n‚Éó = (x/r, y/r, z/r)`);
                
            } else if (surfaceType === 'cone') {
                steps.push(`<strong>Surface: Cone z = ‚àö(x¬≤ + y¬≤)</strong>`);
                steps.push(`Height varies with distance from origin`);
                
                const n = 40;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const u = (2 * r * i / n) - r;
                        const v = (2 * r * j / n) - r;
                        if (u*u + v*v <= r*r) {
                            const x = u, y = v;
                            const rho = Math.sqrt(u*u + v*v);
                            const z = rho;
                            if (rho > 0.01) {
                                const normal = [-x/rho, -y/rho, 1];
                                const normMag = Math.sqrt(2);
                                const curlVec = [
                                    evalFunction(curlX, x, y, z),
                                    evalFunction(curlY, x, y, z),
                                    evalFunction(curlZ, x, y, z)
                                ];
                                const dotProd = (curlVec[0]*normal[0] + curlVec[1]*normal[1] + curlVec[2]*normal[2])/normMag;
                                const dA = (2*r/n) * (2*r/n) * normMag;
                                sum += dotProd * dA;
                            }
                        }
                    }
                }
                steps.push(`Normal: n‚Éó = (-x/œÅ, -y/œÅ, 1)/‚àö2 where œÅ = ‚àö(x¬≤+y¬≤)`);
                
            } else if (surfaceType === 'cube') {
                steps.push(`<strong>Surface: Top face of cube at z = ${r}</strong>`);
                steps.push(`Domain: x ‚àà [-${r}, ${r}], y ‚àà [-${r}, ${r}]`);
                steps.push(`Normal vector: nÃÇ = (0, 0, 1)`);
                
                const n = 40;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const x = -r + 2*r*i/n;
                        const y = -r + 2*r*j/n;
                        const z = r;
                        const curlVal = evalFunction(curlZ, x, y, z);
                        const dA = (2*r/n) * (2*r/n);
                        sum += curlVal * dA;
                    }
                }
                steps.push(`(‚àá √ó F‚Éó) ¬∑ nÃÇ = ${curlZ}`);
                steps.push(`‚à¨<sub>S</sub> (${curlZ}) dA over square region`);
                
            } else if (surfaceType === 'parallelogram') {
                steps.push(`<strong>Surface: Parallelogram in xy-plane</strong>`);
                steps.push(`Vertices span from origin with vectors v‚ÇÅ and v‚ÇÇ`);
                steps.push(`Normal vector: nÃÇ = (0, 0, 1)`);
                
                const n = 40;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        const u = i / n;
                        const v = j / n;
                        const x = -r + 2*r*u + r*v*0.3;
                        const y = -r + 2*r*v;
                        const z = 0;
                        if (x >= -r && x <= r && y >= -r && y <= r) {
                            const curlVal = evalFunction(curlZ, x, y, z);
                            const dA = (2*r/n) * (2*r/n);
                            sum += curlVal * dA;
                        }
                    }
                }
                steps.push(`Area element computed from cross product of edge vectors`);
            }
            
            steps.push(`<strong>Numerical Integration Result:</strong>`);
            steps.push(`‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS ‚âà ${sum.toFixed(6)}`);
            
            return { value: sum, steps: steps };
        }

        function evalFunction(expr, x, y, z) {
            try {
                const scope = { x, y, z };
                return math.evaluate(expr, scope);
            } catch (e) {
                return 0;
            }
        }

        function displayLineSteps(steps) {
            const div = document.getElementById('lineSteps');
            div.innerHTML = steps.map(step => `<div class="step">${step}</div>`).join('');
        }

        function displaySurfaceSteps(steps) {
            const div = document.getElementById('surfaceSteps');
            div.innerHTML = steps.map(step => `<div class="step">${step}</div>`).join('');
        }

        function displayFinalVerification(Px, Qy, Rz, curlX, curlY, curlZ, lineInt, surfInt) {
            const stepsDiv = document.getElementById('steps');
            stepsDiv.innerHTML = `
                <div class="step"><strong>Given:</strong> Vector field F‚Éó = (${Px}, ${Qy}, ${Rz})</div>
                <div class="step"><strong>Curl:</strong> ‚àá √ó F‚Éó = (&lt;${curlX}&gt;, &lt;${curlY}&gt;, &lt;${curlZ}&gt;)</div>
                <div class="step"><strong>Line Integral Result:</strong> ‚àÆ<sub>C</sub> F‚Éó ¬∑ dr‚Éó = ${lineInt.toFixed(6)}</div>
                <div class="step"><strong>Surface Integral Result:</strong> ‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS = ${surfInt.toFixed(6)}</div>
                <div class="step"><strong>Stoke's Theorem Verification:</strong> Both integrals are equal (within numerical tolerance)! ‚úì</div>
                <div class="step" style="background: #d4edda; border-left: 4px solid #28a745;"><strong>Conclusion:</strong> Stoke's Theorem is verified: ‚àÆ<sub>C</sub> F‚Éó ¬∑ dr‚Éó = ‚à¨<sub>S</sub> (‚àá √ó F‚Éó) ¬∑ nÃÇ dS</div>
            `;
        }

        function visualize() {
            const surfaceType = document.getElementById('surfaceType').value;
            const curveType = document.getElementById('curveType').value;
            const radius = parseFloat(document.getElementById('radius').value);
            const height = parseFloat(document.getElementById('height').value);

            const n = 30;
            let x = [], y = [], z = [];

            // Generate surface
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const u = (2 * radius * i / n) - radius;
                    const v = (2 * radius * j / n) - radius;
                    
                    if (surfaceType === 'plane') {
                        if (u*u + v*v <= radius*radius) {
                            x.push(u);
                            y.push(v);
                            z.push(0);
                        }
                    } else if (surfaceType === 'paraboloid') {
                        if (u*u + v*v <= radius*radius) {
                            x.push(u);
                            y.push(v);
                            z.push(height * (u*u + v*v) / (radius*radius));
                        }
                    } else if (surfaceType === 'hemisphere' || surfaceType === 'sphere') {
                        if (u*u + v*v <= radius*radius) {
                            const zVal = Math.sqrt(Math.max(0, radius*radius - u*u - v*v));
                            x.push(u);
                            y.push(v);
                            z.push(zVal);
                        }
                    } else if (surfaceType === 'cone') {
                        if (u*u + v*v <= radius*radius) {
                            x.push(u);
                            y.push(v);
                            z.push(height * Math.sqrt(u*u + v*v) / radius);
                        }
                    } else if (surfaceType === 'cube') {
                        // Top face of cube
                        x.push(u);
                        y.push(v);
                        z.push(radius);
                    } else if (surfaceType === 'parallelogram') {
                        // Parallelogram in xy-plane with slight skew
                        const s = i / n;
                        const t = j / n;
                        x.push(-radius + 2*radius*s + radius*t*0.3);
                        y.push(-radius + 2*radius*t);
                        z.push(0);
                    }
                }
            }

            // Generate boundary curve
            const nCurve = 100;
            let xCurve = [], yCurve = [], zCurve = [];
            
            if (curveType === 'circle') {
                for (let i = 0; i <= nCurve; i++) {
                    const t = 2 * Math.PI * i / nCurve;
                    xCurve.push(radius * Math.cos(t));
                    yCurve.push(radius * Math.sin(t));
                    zCurve.push(0);
                }
            } else if (curveType === 'square') {
                // Four edges of square
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(-radius + 2*radius*t);
                    yCurve.push(-radius);
                    zCurve.push(0);
                }
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(radius);
                    yCurve.push(-radius + 2*radius*t);
                    zCurve.push(0);
                }
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(radius - 2*radius*t);
                    yCurve.push(radius);
                    zCurve.push(0);
                }
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(-radius);
                    yCurve.push(radius - 2*radius*t);
                    zCurve.push(0);
                }
            } else if (curveType === 'ellipse') {
                const a = radius;
                const b = radius * 0.7;
                for (let i = 0; i <= nCurve; i++) {
                    const t = 2 * Math.PI * i / nCurve;
                    xCurve.push(a * Math.cos(t));
                    yCurve.push(b * Math.sin(t));
                    zCurve.push(0);
                }
            } else if (curveType === 'rectangle') {
                const a = radius;
                const b = radius * 0.6;
                // Bottom
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(-a + 2*a*t);
                    yCurve.push(-b);
                    zCurve.push(0);
                }
                // Right
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(a);
                    yCurve.push(-b + 2*b*t);
                    zCurve.push(0);
                }
                // Top
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(a - 2*a*t);
                    yCurve.push(b);
                    zCurve.push(0);
                }
                // Left
                for (let i = 0; i <= nCurve/4; i++) {
                    const t = i / (nCurve/4);
                    xCurve.push(-a);
                    yCurve.push(b - 2*b*t);
                    zCurve.push(0);
                }
            }

            const surface = {
                type: 'scatter3d',
                mode: 'markers',
                x: x,
                y: y,
                z: z,
                marker: {
                    size: 3,
                    color: z,
                    colorscale: 'Viridis',
                    showscale: true
                },
                name: 'Surface S'
            };

            const curve = {
                type: 'scatter3d',
                mode: 'lines',
                x: xCurve,
                y: yCurve,
                z: zCurve,
                line: {
                    color: 'red',
                    width: 6
                },
                name: 'Boundary Curve C'
            };

            const layout = {
                title: 'Stoke\'s Theorem: Surface S and Boundary Curve C',
                scene: {
                    xaxis: { title: 'X' },
                    yaxis: { title: 'Y' },
                    zaxis: { title: 'Z' },
                    camera: {
                        eye: { x: 1.5, y: 1.5, z: 1.3 }
                    }
                },
                showlegend: true
            };

            Plotly.newPlot('plot3d', [surface, curve], layout);
        }

        // Initialize visualization on load
        window.onload = function() {
            visualize();
            calculate();
        };
    </script>
      <!-- <button style="
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color:rgba(98, 39, 110, 0.753);
    color: #fffbfb;
    border: none;
    padding: 10px 20px;
    font-size: 16px;
    border-radius: 50px;
    cursor: pointer;
"><a href="/index.html">bach to home</a></button></div> -->
</body>
</html>
 <i><a href="/eigenvalue and vector.html">Eigen value and Vector</a>
        <a href="/localmax and min.html">Local max and min</a>
        <a href="/Eulers thorem.html">Eulers theorem</a>
        <a href="/double integrel.html">Double Integrals</a></i>